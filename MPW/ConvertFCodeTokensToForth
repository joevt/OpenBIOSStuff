# Set 1 "MacOS9:System Folder:Preferences:MPW:TempMPW:Part2.txt"# Set 1 "{TempFolder}FCode0.of"Set hasPCIHeader "{2}" # header info is in "{TempFolder}PCIHeader"# Set hasPCIHeader 1If "{hasPCIHeader}" == ""	Set hasPCIHeader 0EndSet FCode "{TempFolder}FCode.of"Set FCode1 "{TempFolder}FCode1.of"Set FCode2 "{TempFolder}FCode2.of"Set FCode3 "{TempFolder}FCode3.of"#Set FCode4 "{TempFolder}FCode4.of"Close -y "{FCode}" ³ Dev:Null || ()Duplicate -y "{{1}}" "{FCode}"Open -h "{FCode}"Find ¥ "{FCode}"Find ¥ "{FCode}"Find // "{FCode}" && Exit 1 # make sure our special escape character (ctrl-k) doesnÕt exist# pci headerIf {HasPCIheader} - 0	Find ¥ "{FCode}"	Catenate "{TempFolder}PCIHeader" > "{FCode}".¤End# fcode-version2Set gotstart 0Find ¥ "{FCode}"Replace -c ° /'start1 '('\ [0x0f1] ')Ç0,1È"¶n  "('format:    0x08')¨1"¶n  "('checksum:  0x'[0-9A-F]+' ('Å')')¨2"¶n  "('len:       0x'[0-9A-F]+' ('[0-9]+' bytes)')¨3/ "fcode-version2¶n\ "¨1"¶n\ "¨2"¶n\ "¨3"¶nhex¶n¶n" "{FCode}" && Set gotstart 1Find ¥ "{FCode}"Replace -c ° /'version1 '('\ [0x0fd] ')Ç0,1È"¶n  "('format:    0x08')¨1"¶n  "('checksum:  0x'[0-9A-F]+' ('Å')')¨2"¶n  "('len:       0x'[0-9A-F]+' ('[0-9]+' bytes)')¨3/ "fcode-version1¶n\ "¨1"¶n\ "¨2"¶n\ "¨3"¶nhex¶n¶n" "{FCode}" && Set gotstart 1If {gotstart} == 0	Echo "# DidnÕt get start fcode" ³ Dev:StdErrEnd# figure out what the indent character isSet indentChar "¶t"Set indent "¶t"Find ¥ "{FCode}"Find /¥[ ]/ "{FCode}" && Begin	Set indentChar " "	Set indent "    "End || ()Set indents "[{indentChar}]*"#Set indents "[	]*"# fcode-end, pci-endSet gotend 0Find ¥ "{FCode}"Replace -c ° /¥([{indentChar}]*)¨1'end0 '('\ [0x000] ')Ç0,1È"¶n\ detokenizing finished after "Å"bytes.¶n"/ "¶n"¨1"fcode-end¶n" "{FCode}" && Set gotend 1If {HasPCIheader} - 0	Replace ° "pci-end¶n" "{FCode}"EndIf {gotend} == 0	Echo "# DidnÕt get end fcode" ³ Dev:StdErr	Exit 1EndSet missing ""Find ¥ "{FCode}"Replace -c ° /¥([{indentChar}]*)¨1'b(lit) '(('\ [0x010] ')Ç0,1È)¨3'0xffffffff'/ ¨1'-1 '¨3	"{FCode}" || Set missing "{{missing}}¶nb(lit) A-Fxxx" # b(lit) FFFFFFFFFind ¥ "{FCode}"Replace -c ° /¥([{indentChar}]*)¨1'b(lit) '(('\ [0x010] ')Ç0,1È)¨3'0x'([A-F][0-9A-F]*)¨2/ ¨1'0'¨2' '¨3	"{FCode}" || Set missing "{{missing}}¶nb(lit) A-Fxxx" # b(lit) A-FxxxFind ¥ "{FCode}"Replace -c ° /¥([{indentChar}]*)¨1'b(lit) '(('\ [0x010] ')Ç0,1È)¨3'0x'([0-9][0-9A-F]*)¨2/ ¨1¨2' '¨3		"{FCode}" || Set missing "{{missing}}¶nb(lit) 0-9xxx" # b(lit) 0-9xxx#	external        Newly created functions will be visible.  Arrange for subsequently created FCode functions to use external-token#	headers         Newly created functions will be optionally visible.  Arrange for subsequently created FCode functions to use named-token#	headerless      Newly created functions will be invisible.  Arrange for subsequently created FCode functions to use new-token#	instance        value, variable, defer, or buffer:              Used as: ok 30 instance value new-name##	new-token       (Tokenized by defining words in headerless mode)        new-token fcode#	named-token     (Tokenized by defining words in headers mode)           named-token name fcode#	external-token  (Tokenized by defining words in external mode)          external-token name fcode###	buffer:         new-token|named-token|external-token b(buffer:)         num <instance> buffer: name#	value			new-token|named-token|external-token b(value)           num <instance> value name##	defer			new-token|named-token|external-token b(defer)           <instance> defer name#	variable		new-token|named-token|external-token b(variable)        <instance> variable name##	constant        new-token|named-token|external-token b(constant)        num constant name#	field           new-token|named-token|external-token b(field)           num field name##	:               new-token|named-token|external-token b(:)				: name#	create          new-token|named-token|external-token b(create)          create name#set echo 0For theword in ¶		'num <instance> buffer: name buffer' ¶		'num <instance> value name value' ¶		'<instance> defer name defer_word_function' ¶		'<instance> variable name variable' ¶		'num constant name const' ¶		'num field name field' ¶		': name colon_definition_function' ¶		'create name create_word_function'	If "{theword}" =~ /((num )*)¨1((<instance> )*)¨2(Å)¨3 name (Å)¨4/		For numTry In {¨1} "" # counts once or twice depending on {¨1}			Set num "()¨6"			Set num2 ""			Set num3 ""			Set num4 ""			Set instance "()¨8"			Set instance2 ""			If "{¨1}"				Set ¨1 "" # try again without number				Set num "([-]Ç0,1È[0-9][0-9A-F]*)¨2 (('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨6¶n"				Set num2 '¨2" "'				Set num3 '"_"¨2'				Set num4 '" "¨2'			End			If "{¨2}"				Set instance "(([{indentChar}]*'instance '(('\ [0x0c0] ')Ç0,1È)¨8¶n)*)¨4"				Set instance2 '¨4'			End			# replace [num instance xxx-token newfcode# fcode#] with [instance xxx num forthword name comments]			Find ¥ "{FCode}"			Replace -c ° /¥([{indentChar}]*)¨1{num}{instance}[{indentChar}]*'new-token '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨7'0x'([0-9A-F]+)¨3¶n[{indentChar}]*"b({¨3}) "/					{instance2}'new'¨1{num2}"{¨3} {¨4}_"¨3{num3}' \ ('¨3{num4}') '¨6''¨7  "{FCode}" || Set missing "{{missing}}¶nnew {numTry} {¨1}{¨3}"			Find ¥ "{FCode}"			Replace -c ° /¥([{indentChar}]*)¨1{num}{instance}[{indentChar}]*'named-token '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨7([Â ]+)¨5' 0x'([0-9A-F]+)¨3¶n[{indentChar}]*"b({¨3}) "/		{instance2}'named'¨1{num2}"{¨3} "¨5' \ ('¨3{num4}') '¨6''¨7           "{FCode}" || Set missing "{{missing}}¶nnamed {numTry} {¨1}{¨3}"			Find ¥ "{FCode}"			Replace -c ° /¥([{indentChar}]*)¨1{num}{instance}[{indentChar}]*'external-token '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨7([Â ]+)¨5' 0x'([0-9A-F]+)¨3¶n[{indentChar}]*"b({¨3}) "/		{instance2}'external'¨1{num2}"{¨3} "¨5' \ ('¨3{num4}') '¨6''¨7        "{FCode}" || Set missing "{{missing}}¶nexternal {numTry} {¨1}{¨3}"		End	Else		# Echo bad		Exit 1	EndEndFind ¥ "{FCode}"Replace -c ° /¥[{indentChar}]*'instance '(('\ [0x0c0] ')Ç0,1È)¨1¶n([Â]+[{indentChar}]*([-0-9][0-9A-F]* )Ç0,1È)¨2([Â]+)¨3/ ¨2"instance "¨3¨1 "{FCode}" || Set missing "{{missing}}¶ninstance" # move instance to between num and forth wordFind ¥ "{FCode}"Replace -c ° /¥([Â]+([{indentChar}]*)¨2('instance ')Ç0,1È': ')¨1/ ¨2¶n¨1 "{FCode}" || Set missing "{{missing}}¶n:" # place a carriage return before :Find ¥ "{FCode}"Replace -c ° /¥([{indentChar}]*)¨2"0 ¶n"([Â]+)¨3([{indentChar}]*[0-9A-F]+ field )¨1/ ¨3¨2"struct ¶n"¨1 "{FCode}" || Set missing "{{missing}}¶nstruct" # replace 0 with struct if it is located before a field instruction# add headerless, headers and external compiler directivesSet nextToken ""Find ¥ "{FCode}"Loop	Find /¥{nextToken}[Â]+[¶t]*/ "{FCode}" || Break	Set theToken "`Catenate "{FCode}".¤`"		If "{theToken}" =~ /([Â]+)¨1([¶t]*)¨2/		If "{¨1}" == "new"			Replace ¤ "{¨2}¶n{¨2}headerless¶n{¨2}" "{FCode}"			Set nextToken "[ne][ax]"		Else If "{¨1}" == "named"			Replace ¤ "{¨2}¶n{¨2}headers¶n{¨2}" "{FCode}"			Set nextToken "[ne][ex]"		Else If "{¨1}" == "external"			Replace ¤ "{¨2}¶n{¨2}external¶n{¨2}" "{FCode}"			Set nextToken "n"		End	EndEndFind ¥ "{FCode}"Clear -c ° /¥[Â]+/ "{FCode}" || Set missing "{{missing}}¶nnew, named, external" # new, named, externalFind ¥ "{FCode}"Replace -c ° // '' "{FCode}" || ()# set missing "" ; set echo 1; set echo 0#Find ¥ "{FCode}"#Replace -c ° /([ ¶t¶n])¨1'(unnamed-fcode)'(' \ [0x'([0-9A-F]Ç3È)¨3'] ')¨2/ ¨1"unnamed-fcode_"¨3¨2 "{FCode}" || Set missing "{{missing}}¶n(unnamed-fcode)" # unnamed-fcodeFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b(;) '(('\ [0x0c2] ')Ç0,1È)¨2/ ¨1"; "¨2"¶n"¨1 "{FCode}" || Set missing "{{missing}}¶nb(;)" # b(;) -> ;Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1"b(') "(('\ [0x011] ')Ç0,1È)¨2([Â ]+ )¨4(('\ [0x'[0-9a-f]Ç3È'] ')Ç0,1È)¨3¶n/ ¨1"['] "¨4¨2¨3"¶n" "{FCode}" || Set missing "{{missing}}¶nb(')" # b(') -> [']Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b(") '(('\ [0x012] ')Ç0,1È)¨2(Å)¨3/ ¨1¨3¨2 "{FCode}" || Set missing "{{missing}}¶nb(¶")" # b(") -> "If 0	# lets not rename the new names to the old names	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'lshift '/ ¨1'<< ' "{FCode}" || Set missing "{{missing}}¶n<<" # lshift -> <<	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'rshift '/ ¨1'>> ' "{FCode}" || Set missing "{{missing}}¶n>>" # rshift -> >>	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'chars '/ ¨1'/c* ' "{FCode}" || Set missing "{{missing}}¶n/c*" # chars -> /c*	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'char+ '/ ¨1'ca1+ ' "{FCode}" || Set missing "{{missing}}¶nca1+" # char+ -> ca1+	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'cells '/ ¨1'/n* ' "{FCode}" || Set missing "{{missing}}¶n/n*" # cells -> /n*	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'cell+ '/ ¨1'na1+ ' "{FCode}" || Set missing "{{missing}}¶nna1+" # cell+ -> na1+	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'invert '/ ¨1'not ' "{FCode}" || Set missing "{{missing}}¶nnot" # invert -> not	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'evaluate '/ ¨1'eval' "{FCode}" || Set missing "{{missing}}¶neval" # evaluate -> evalEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'@ '(('\ [0x06d] ')Ç0,1È)¨2¶n{indents}'. '(('\ [0x09d] ')Ç0,1È)¨3/ ¨1'? '¨2¨3 "{FCode}" || Set missing "{{missing}}¶n?" # @ . -> ?Find ¥ "{FCode}"Replace -c ° /¥({indents}[1-2])¨1 (('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨3¶n{indents}([-+])¨2 (('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨4/ ¨1¨2" "¨3¨4 "{FCode}" || Set missing "{{missing}}¶n1+ 1- 2+ 2-" # 1 + 1 - 2 + 2 - -> 1+ 1- 2+ 2-Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1('" 'Å)¨2¶n{indents}type / ¨1'.'¨2 "{FCode}" || Set missing "{{missing}}¶n.¶"" # " type -> ."Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1'bl '(('\ [0x0a9] ')Ç0,1È)¨2¶n{indents}'fill '(('\ [0x079] ')Ç0,1È)¨3/ ¨1'blank '¨2¨3 "{FCode}" || Set missing "{{missing}}¶nblank" # bl fill -> blankFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'0a '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'base '(('\ [0x0a0] ')Ç0,1È)¨3¶n{indents}'! '/ ¨1'decimal '¨2¨3 "{FCode}" || Set missing "{{missing}}¶ndecimal" # 0a base ! -> decimalFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'8 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'base '(('\ [0x0a0] ')Ç0,1È)¨3¶n{indents}'! '/ ¨1'octal '¨2¨3 "{FCode}" || Set missing "{{missing}}¶noctal" # 8 base ! -> octalFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'10 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'base '(('\ [0x0a0] ')Ç0,1È)¨3¶n{indents}'! '/ ¨1'hex '¨2¨3 "{FCode}" || Set missing "{{missing}}¶nhex" # 10 base ! -> hexFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'0 \ [0x0a5] '¶n{indents}'max \ [0x02f] '¶n{indents}'0 \ [0x0a5] '¶n{indents}'b(?do) \ [0x018] 0x7'¶n{indents}'0 \ [0x0a5] '¶n{indents}'c, \ [0x0d0] '¶n{indents}'b(loop) \ [0x015] 0xfffffffd'/ ¨1'allot \ [0x0a5] \ [0x02f] \ [0x0a5] \ [0x018] \ [0x0a5] \ [0x0d0] \ [0x015] ' "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'0 '¶n{indents}'max '¶n{indents}'0 '¶n{indents}'b(?do) 0x7'¶n{indents}'0 '¶n{indents}'c, '¶n{indents}'b(loop) 0xfffffffd'/ ¨1'allot ' "{FCode}" || Set missing "{{missing}}¶nallot" # 0 max 0 b(?do) 0 c, b(loop) -> allotEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'span \ [0x088] '¶n{indents}'@ \ [0x06d] '¶n{indents}'-rot \ [0x04b] '¶n{indents}'expect \ [0x08a] '¶n{indents}'span \ [0x088] '¶n{indents}'@ \ [0x06d] '¶n{indents}'swap \ [0x049] '¶n{indents}'span \ [0x088] '¶n{indents}'! '/ ¨1'accept \ [0x088] \ [0x06d] \ [0x04b] \ [0x08a] \ [0x088] \ [0x06d] \ [0x049] \ [0x088] ' "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'span '¶n{indents}'@ '¶n{indents}'-rot '¶n{indents}'expect '¶n{indents}'span '¶n{indents}'@ '¶n{indents}'swap '¶n{indents}'span '¶n{indents}'! '/ ¨1'accept ' "{FCode}" || Set missing "{{missing}}¶naccept" # span @ -rot expect span @ swap span ! -> acceptEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'>r \ [0x030] '¶n{indents}'over \ [0x048] '¶n{indents}'r@ \ [0x032] '¶n{indents}'+ \ [0x01e] '¶n{indents}'swap \ [0x049] '¶n{indents}'r@ \ [0x032] '¶n{indents}'- \ [0x01f] '¶n{indents}'rot \ [0x04A] '¶n{indents}'r> '/ ¨1'decode-bytes \ [0x030] \ [0x048] \ [0x032] \ [0x01e] \ [0x049] \ [0x032] \ [0x01f] \ [0x04A] ' "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'>r '¶n{indents}'over '¶n{indents}'r@ '¶n{indents}'+ '¶n{indents}'swap '¶n{indents}'r@ '¶n{indents}'- '¶n{indents}'rot '¶n{indents}'r> '/ ¨1'decode-bytes ' "{FCode}" || Set missing "{{missing}}¶ndecode-bytes" # >r over r@ + swap r@ - rot r> -> decode-bytesEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'base \ [0x0a0] '¶n{indents}'@ \ [0x06d] '¶n{indents}'swap \ [0x049] '¶n{indents}'decimal '(('\ [0x'[0-9A-F]Ç3È'] ')*)¨5¶n{indents}'. \ [0x09d] '¶n{indents}'base \ [0x0a0] '¶n{indents}'! \ [0x072] '/ ¨1".d \ [0x0a0] \ [0x06d] \ [0x049] "¨5"\ [0x09d] \ [0x0a0] \ [0x072] " "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'base '¶n{indents}'@ '¶n{indents}'swap '¶n{indents}'decimal '¶n{indents}'. '¶n{indents}'base '¶n{indents}'! '/ ¨1'.d' "{FCode}" || Set missing "{{missing}}¶n.d" # base @ swap decimal . base ! -> .dEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'base \ [0x0a0] '¶n{indents}'@ \ [0x06d] '¶n{indents}'swap \ [0x049] '¶n{indents}'hex '(('\ [0x'[0-9A-F]Ç3È'] ')*)¨5¶n{indents}'. \ [0x09d] '¶n{indents}'base \ [0x0a0] '¶n{indents}'! \ [0x072] '/ ¨1".h \ [0x0a0] \ [0x06d] \ [0x049] "¨5"\ [0x09d] \ [0x0a0] \ [0x072] " "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'base '¶n{indents}'@ '¶n{indents}'swap '¶n{indents}'hex '¶n{indents}'. '¶n{indents}'base '¶n{indents}'! '/ ¨1'.h' "{FCode}" || Set missing "{{missing}}¶n.h" # base @ swap hex . base ! -> .hEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'dup '(('\ [0x047] ')Ç0,1È)¨2¶n{indents}'abs '(('\ [0x02d] ')Ç0,1È)¨3¶n{indents}'<# '(('\ [0x096] ')Ç0,1È)¨4¶n{indents}'u#s '(('\ [0x09a] ')Ç0,1È)¨5¶n{indents}'swap '(('\ [0x049] ')Ç0,1È)¨6¶n{indents}'sign '(('\ [0x098] ')Ç0,1È)¨7¶n{indents}'u#> '/ ¨1'(.) '¨2¨3¨4¨5¨6¨7 "{FCode}" || Set missing "{{missing}}¶n(.)" # dup abs <# u#s swap sign u#> -> (.)#Find ¥ "{FCode}"#Replace -c ° /¥({indents})¨1'dup '¶n{indents}'abs '¶n{indents}'<# '¶n{indents}'u#s '¶n{indents}'swap '¶n{indents}'sign '¶n{indents}'u#> '/ ¨1'(.)' "{FCode}" || Set missing "{{missing}}¶n(.)" # dup abs <# u#s swap sign u#> -> (.)Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1'2 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'pick '(('\ [0x04e] ')Ç0,1È)¨3¶n{indents}'2 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨4¶n{indents}'pick '(('\ [0x04e] ')Ç0,1È)¨5¶n{indents}'2 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨6¶n{indents}'pick '/ ¨1'3dup '¨2¨3¨4¨5¨6 "{FCode}" || Set missing "{{missing}}¶n3dup" # 2 pick 2 pick 2 pick -> 3dupFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b?branch '(('\ [0x014] ')Ç0,1È)¨2'0x4'¶n{indents}'b(leave) '(('\ [0x01b] ')Ç0,1È)¨3¶n{indents}'b(>resolve) '/ ¨1'?leave '¨2¨3 "{FCode}" || Set missing "{{missing}}¶n?leave" # b?branch b(leave) b(>resolve) -> ?leaveFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'bl '(('\ [0x0a9] ')Ç0,1È)¨2¶n{indents}'emit '/ ¨1'space '¨2 "{FCode}" || Set missing "{{missing}}¶nspace" # bl emit -> spaceFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'(.) '(('\ [0x'[0-9A-F]Ç3È'] ')*)¨2¶n{indents}'type '(('\ [0x090] ')Ç0,1È)¨3¶n{indents}'space '/ ¨1's. '¨2¨3 "{FCode}" || Set missing "{{missing}}¶ns." # (.) type space -> s.Find ¥ "{FCode}"#Replace -c ° /¥({indents})¨1'0 '('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'max \ [0x02f] '¶n{indents}'0 '('\ [0x'[0-9A-F]Ç3È'] ')¨4¶n{indents}'b(?do) \ [0x018] 0x7'¶n{indents}'space \ [0x0a9] \ [0x08f] '¶n{indents}'b(loop) \ [0x015] 0xfffffffd'/ ¨1'spaces '¨2'\ [0x02f] '¨4' \ [0x018] \ [0x0a9] \ [0x08f] \ [0x015] ' "{FCode}" || Set missing "{{missing}}¶nspaces" # 0 max 0 b(?do) space b(loop) -> spacesReplace -c ° /¥({indents})¨1'0 \ [0x0a5] '¶n{indents}'max \ [0x02f] '¶n{indents}'0 \ [0x0a5] '¶n{indents}'b(?do) \ [0x018] 0x7'¶n{indents}'space \ [0x0a9] \ [0x08f] '¶n{indents}'b(loop) \ [0x015] 0xfffffffd'/ ¨1'spaces \ [0x0a5] \ [0x02f] \ [0x0a5] \ [0x018] \ [0x0a9] \ [0x08f] \ [0x015] ' "{FCode}" || Begin	Find ¥ "{FCode}"	Replace -c ° /¥({indents})¨1'0 '¶n{indents}'max '¶n{indents}'0 '¶n{indents}'b(?do) 0x7'¶n{indents}'space '¶n{indents}'b(loop) 0xfffffffd'/ ¨1'spaces ' "{FCode}" || Set missing "{{missing}}¶nspaces" # 0 max 0 b(?do) space b(loop) -> spacesEndFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'<# '(('\ [0x096] ')Ç0,1È)¨2¶n{indents}'u#s '(('\ [0x09a] ')Ç0,1È)¨3¶n{indents}'u#> '/ ¨1'(u.) '¨2¨3 "{FCode}" || Set missing "{{missing}}¶n(u.)" # <# u#s u#> -> (u.)Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1'drop '(('\ [0x046] ')Ç0,1È)¨2¶n{indents}'2drop '/ ¨1'3drop '¨2 "{FCode}" || Set missing "{{missing}}¶n3drop" # drop 2drop -> 3dropFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'0 '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨2¶n{indents}'fill '/ ¨1'erase '¨2 "{FCode}" || Set missing "{{missing}}¶nerase" # 0 fill -> eraseFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b('([a-z+?]+)¨2') '(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨4(0x[0-9A-F]+)¨3/ ¨1¨2' \ ('¨3') '¨4 "{FCode}" || Set missing "{{missing}}¶nb(loop,do,?do,endof,of)" # b(loop) b(+loop) b(do) b(?do) b(endof) b(of)Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1"b(to) "(('\ [0x0c3] ')Ç0,1È)¨2([Â ]+ )¨4(('\ [0x'[0-9a-f]Ç3È'] ')Ç0,1È)¨3¶n/ ¨1"to "¨4¨2¨3"¶n" "{FCode}" || Set missing "{{missing}}¶nb(to)" # b(to) -> toFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b('([a-z+?]+)¨2') '/ ¨1¨2' ' "{FCode}" || Set missing "{{missing}}¶nb(leave,case,endcase,to)" # b(leave) b(case) b(endcase) -> leave case endcaseFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b(<mark) '/ ¨1'begin ' "{FCode}" || Set missing "{{missing}}¶nbegin" # beginFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b?branch '(('\ [0x014] ')Ç0,1È)¨3(0xFFFF[0-9A-F]Ç4È)¨2/ ¨1'until \ ('¨2') '¨3 "{FCode}" || Set missing "{{missing}}¶nuntil" # untilFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1{indent}'bbranch '(('\ [0x013] ')Ç0,1È)¨3(0x[0-9A-F]Ç1,4È)¨2¶n{indents}'b(>resolve) '/ ¨1'else \ ('¨2') '¨3 "{FCode}" || Set missing "{{missing}}¶nelse" # elseFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'bbranch '(('\ [0x013] ')Ç0,1È)¨3(0x[0-9A-F]Ç1,4È)¨2¶n{indents}'b(>resolve) '/ ¨1'else \ ('¨2') '¨3 "{FCode}" && (Beep; Echo "Got bad Else" ³ Dev:StdErr) # else#Find ¥ "{FCode}"#Replace -c ° /¥({indents})¨1'bbranch '(('\ [0x013] ')Ç0,1È)¨3(0xFFFF[0-9A-F]Ç4È)¨2¶n{indents}'b(>resolve) '/ ¨1'repeat \ ('¨2') '¨3 "{FCode}" || Set missing "{{missing}}¶nrepeat" # repeatFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'bbranch '(('\ [0x013] ')Ç0,1È)¨3(0xFFFF[0-9A-F]Ç4È)¨2/ ¨1'again \ ('¨2') '¨3 "{FCode}" || Set missing "{{missing}}¶nagain" # againFind ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b(>resolve) '/ ¨1'then ' "{FCode}" || Set missing "{{missing}}¶nthen" # then#If 1Find ¥ "{FCode}"Replace -c ° /¥({indents})¨1'b?branch '(('\ [0x014] ')Ç0,1È)¨3(0x[0-9A-F]Ç1,4È)¨2/ ¨1'if \ ('¨2') '¨3 "{FCode}" || Set missing "{{missing}}¶nif" # ifFind ¥ "{FCode}"Loop	Find /¥{indents}'if \ ('0x[0-9A-F]Ç1,4È') '('\ [0x014] ')Ç0,1È/ "{FCode}" || Break	If "`Catenate "{FCode}".¤`" =~ /({indents})¨1'if'(' \ (0x'[0-9A-F]Ç1,4È') '('\ [0x014] ')*)¨2/# End		Mark -y ¤ branchpos "{FCode}"		Find /¥{¨1}[Â¶t ¶"¶']+ /:\¥\  "{FCode}"		If "``Catenate "{FCode}".¤``" =~ /({¨1}{indent})¨3'again'(' \ (0xFFFF'[0-9A-F]Ç4È') '('\ [0x013] ')Ç0,1È)¨4 {¨1}then /#		End			Replace ¤ "{¨1}{indent}repeat{¨4}" "{FCode}"			Replace branchpos "{¨1}while{¨2}" "{FCode}"		Else			Find branchpos "{FCode}"		End	End # ifEnd # loop#Else#	Find ¥ "{FCode}" # if while#	Loop#		Find /¥{indents}'b?branch '('\ [0x014] ')Ç0,1È0x[0-9A-F]Ç1,4È/ "{FCode}" || Break#		If "`Catenate "{FCode}".¤`" =~ /({indents})¨1'b?branch '(('\ [0x014] ')Ç0,1È)¨4(0x[0-9A-F]Ç1,4È)¨2/#	#		Echo good#	#	End#			Mark -y ¤ branchpos "{FCode}"#			Set numIndentChar `Echo -n "{¨1}" | Count -c`#			Find Æ(/¥[{indentChar}]Ç0,{numIndentChar}È[Â{indentChar}]/:\¥{¨1}{indent}Å\):/{¨1}{indent}[Â ]+/ "{FCode}"#			If "`Catenate "{FCode}".¤`" =~ /{¨1}{indent}([Â ]+)¨3Å/#				If "{¨3}" == "then"#					Replace branchpos "{¨1}if \ ({¨2}) {¨4}" "{FCode}"#				Else If "{¨3}" == "repeat"#					Replace branchpos "{¨1}while \ ({¨2}) {¨4}" "{FCode}"#				Else#					Echo "# unknown b?branch termination" > Dev:StdErr#					Exit 1#				End#			Else#				Echo "# bad b?branch termination" > Dev:StdErr#				Exit 1#			End#		Else#			Echo "# bad b?branch" > Dev:StdErr#			Exit 1#		End#	End#EndFind ¥ "{FCode}"Replace -c ° /¥': colon_definition_function_'([0-9a-f]Ç3È)¨1( Å¶n{indent}'" '([Â ¶n¶"]*)¨3'" 'Å¶n{indent}'; ')¨2/ ': colon_string_'¨1'_'¨3¨2 "{FCode}" || Set missing "{{missing}}¶ncolon_string" # colon_definition -> colon_stringFind ¥ "{FCode}"Replace -c ° /¥': colon_definition_function_'([0-9a-f]Ç3È)¨1( Å¶n{indent}([0-9][0-9a-f]*)¨3 Å¶n{indent}'; ')¨2/ ': colon_const_'¨1'_'¨3¨2 "{FCode}" || Set missing "{{missing}}¶ncolon_const" # colon_definition -> colon_const#StreamEdit "{FCode}" -s "{MPWCommands}DumpPCIRomStreamEdit1" > "{TempFolder}commands"For theword In buffer_ value_ defer_word_function_ variable_ const_ field_ colon_ create_word_function_	Search -s -ns /"{theword}"/ "{FCode}"End | StreamEdit -e "/'; Line '([0-9]+)¨1' ¶t# '(Å)¨2/ Change ¨1'¶t'¨2" | Sort -f 1d -r > "{TempFolder}defines"Echo -n > "{TempFolder}commands"StreamEdit -d -set thefile="{TempFolder}commands" "{TempFolder}defines" -s "{MPWCommands}DumpPCIRomStreamEdit1"Close -n "{FCode1}" ³ Dev:Null || ()#Set starttime `TickCount`StreamEdit "{FCode}" -s "{TempFolder}commands" > "{FCode1}" # get list of tokens#Set stoptime `TickCount`#Evaluate {stoptime} - {starttime}Close -y "{FCode}" ³ Dev:Null || () # done with this so close itClose -n "{FCode2}" ³ Dev:Null || ()StreamEdit "{FCode1}" -e ¶"/¥({indents})¨1{indent}(thenÅ)¨2/ || /¥({indents})¨1{indent}(untilÅ)¨2/ || /¥({indents})¨1{indent}(againÅ)¨2/ || /¥({indents})¨1{indent}(endcaseÅ)¨2/ || /¥({indents})¨1{indent}(endofÅ)¨2/ || /¥({indents})¨1{indent}([+]*loopÅ)¨2/ || /¥({indents})¨1{indent}{indent}(repeatÅ)¨2/ Change ¨1¨2" ¶ > "{FCode2}" # outdent (then, until, again, loop, +loop, endcase, and repeat) but donÕt outdent else because it was done above#set echo 0Close -n "{FCode3}" ³ Dev:Null || ()StreamEdit "{FCode2}" -s "{MPWCommands}DumpPCIRomStreamEdit2" > "{FCode3}" # convert indent spaces to tabs, convert comment spaces to tabs, clear all extra back slashes, clean up comments# dump debug stuffStreamEdit "{FCode3}" -e "!/'unnamed_fcode_'/ Delete" > Dev:StdErrEcho "{{missing}}" > Dev:StdErrCatenate "{FCode3}"Exit 0(('\ [0x___] ')Ç0,1È)¨2¶n(('\ [0x'[0-9A-F]Ç3È'] ')Ç0,1È)¨3" ñquoteîstack: ( [text<">< >] -- text-str text-len )code: nonegenerates: b(") len-byte xx-byte É xx-byteGathers the immediately following text string or hex data until reaching the terminator"<whitespace>.." ñdot quoteîstack: ( [text<">] -- )code: nonegenerates: b(") len text typeThis word compiles a text string, delimited by "<whitespace> e.g. ." helloworld" .At execution time, the string is displayed. This word is equivalent to using " text"type .." is normally used only within a de¥nition. The text string will be displayed laterwhen that de¥nition is called. You may wish to follow it with cr to §ush out the textbuffer immediately. Use .( for any printing to be done immediately.s"stack: ( [text<">] -- text-str text-len )generates: b(") len-byte xx-byte xx-byte É xx-byteGather the immediately-following string delimited by " . Return the location of thestring text-str text-len.Since an implementation is only required to provide two temporary buffers, a programcannot depend on the systemÍs ability to simultaneously maintain more than twodistinct interpreted strings. Compiled strings do not have this limitation, since they arenot stored in the temporary buffers.==============bbranch 		(Tokenized by again, repeat, and else) -offset for again and repeat for repeat, b(>resolve) follows bbranchÃ +offset for elseÃ b(>resolve) follows bbranchÃ followed by another b(>resolve) later for then============== b?branch       (Tokenized by until, while, and if)Ã -offset for until +offset for if and while============== b(>resolve)    (Tokenized by else, then, and repeat) Target of forward bbranch or b?branch.==============Ã b(<mark)       (Tokenized by begin)Ã target of backward bbranch or b?branchÃ============================ then Terminate an if statement.==============ÃÃ beginÃ Begin a conditional loop.Ã Tokenizer equivalent: b(<mark)============== if Tokenizer equivalent: b?branch +offset while Mark first clause of a begin...while...repeat loop. Tokenizer equivalent: b?branch +offset==============Ã elseÃ Tokenizer equivalent: bbranch +offset b(>resolve)============== repeat Mark end of a begin...while...repeat loop. Jump to begin. Tokenizer equivalent: bbranch -offset b(>resolve) again End an (infinite) begin...again loop. Tokenizer equivalent: bbranch -offset==============Ã untilÃ End a begin...until loop. Exit loop if flag is nonzero.Ã Tokenizer equivalent: b?branch -offset==============b(<mark) ... bbranch -FCode-offset                    begin ... againb(<mark) ... b?branch -FCode-offset                   begin ... untilbbranch +FCode-offset ... b(>resolve)                 ... else ... thenb?branch +FCode-offset ... b(>resolve)                if ... then                                                      begin ... while ... repeat														bbranch     ( -- )             Unconditional branch FCode. Followed by FCode-offset.b?branch    ( continue? -- )   Conditional branch FCode. Followed by FCode-offset.b(<mark)    ( -- )             Target of backward branches.b(>resolve) ( -- )             Target of forward branches.